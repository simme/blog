<!DOCTYPE html>
<html lang="en">
   <head>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <title>I Am Simme</title>
      <link href="https://fonts.googleapis.com/css?family=Oswald:600&amp;subset=latin-ext" rel="stylesheet">
      <link href="https://iamsim.me/css/master.css" rel="stylesheet">
      <link href="https://iamsim.me/index.xml" rel="alternate" type="application/rss+xml" title="" />
      <link href="https://iamsim.me/index.xml" rel="feed" type="application/rss+xml" title="" />
      <link href="" rel="alternate" type="application/json" title="" />
   </head>
   <body>
      <header class="page-header">
         
            <a href="https://iamsim.me/" class="page-header-logo">I Am Simme</a>
         
         <p>
            A blog about programming, photography and other things I like and don't.
         </p>
      </header>

      <section class="main">


    <article class="post">
      <span class="date">December 22, 2014</span>
      <h1>Taking advantage of Node&#39;s require algorithm with Browserify</h1>
      <div class="content">
         

<p>This morning I read <a href="https://medium.com/node-js-javascript/working-without-frameworks-part-1-b948f281f782">a post</a> written by <a href="https://twitter.com/hij1nx">Paolo Fragomeni</a>. In it he describes how he builds stuff without using a framework. The part that was really eye opening to me though, was the fact that you can have a <code>node_modules</code> directory in other places than in the root of your project.</p>

<p>Thinking about it it seems kind of obvious. However, it <em>is</em> an easy thing to overlook. Paolo didn&rsquo;t dive too deeply into the nitty gritty details, so I&rsquo;ll lay it out in this post.</p>

<p>Here&rsquo;s the gist of it. Say you have a folder structure that looks like this:</p>

<pre><code>my-app/
  assets/
    js/
      node_modules/
        .. your custom front-end modules
      main.js
  node_modues/
    .. lots of modules
</code></pre>

<p>Say <code>main.js</code> looks something like this:</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span></span><span class="kd">var</span> <span class="nx">Application</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;application&#39;</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">app</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Application</span><span class="p">();</span>
<span class="nx">app</span><span class="p">.</span><span class="nx">boostrap</span><span class="p">();</span>
</code></pre></div>

<p>And then you use <a href="http://browserify.org">Browserify</a> to build this with something like:</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span></span>browserify assets/js/main.js &gt; build/app.js
</code></pre></div>

<p>Now.. where does <code>application</code> live? How does Browserify find it? The long answer is described in the <a href="http://nodejs.org/api/modules.html#modules_loading_from_node_modules_folders">Node.js documentation for loading modules</a>. The short answer is: first we look in the <code>node_modules</code> folder inside of the assets folder. If the module we&rsquo;re looking for cannot be found there Node (or Browserify in our case) starts walking up the directory tree looking for another <code>node_modules</code> folder.</p>

<p>So our theoretical <code>application</code> module might live in <code>my-app/assets/js/node_modules/application/</code>. In this folder there&rsquo;d be an <code>index.js</code> file that looks something like this perhaps:</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span></span><span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nx">Application</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">Application</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Some setup logic and stuff.</span>
<span class="p">}</span>

<span class="nx">Application</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">bootstrap</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Magic</span>
<span class="p">};</span>
</code></pre></div>

<p>The thing I <em>don&rsquo;t</em> like about this approach is that it creates tons of <code>index.js</code> files, which might make it hard to tell file from file in your editor or whatever. So what I like to do is to actually have a <code>package.json</code> for each module with only two properties. Like so:</p>
<div class="highlight"><pre><code class="language-json" data-lang="json"><span></span><span class="p">{</span>
  <span class="nt">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;application&quot;</span><span class="p">,</span>
  <span class="nt">&quot;main&quot;</span><span class="p">:</span> <span class="s2">&quot;application.js&quot;</span>
<span class="p">}</span>
</code></pre></div>

<p>This way the module file can be <code>application.js</code>. You end up with a lot of package files instead, but I can live with that.</p>

<h2 id="grouping-modules">Grouping Modules</h2>

<p>One pattern that you might be accustomed to is to group models in one directory, views in one directory, helpers in one etc. You can still do that! Simply by putting your modules inside directories.</p>

<pre><code>node_modules/
  models/
    user-model/
    article-model/
  views/
    user-view/
</code></pre>

<p>Now, to rewuire the <code>user-model</code> module, for example, you&rsquo;d do: <code>require('models/user-model');</code> Notice the lack of <code>./</code> or even worse <code>../</code> in front of the model path. Regardless of from <em>where</em> you are calling <code>require</code> this will still work. Since Browserify will look inside your <code>node_modules</code> folder by default!</p>

<h2 id="gitignore">.gitignore</h2>

<p>If you&rsquo;re like me then you like to ignore the <code>node_modules</code> folder by default. But since in this case the folder would actually contain code that you might not publish as individual modules you probably also want to commit them to you project repo. Easy! Just put <code>!assets/js/node_modules</code> in your <code>.gitignore</code> and commit away!</p>

<h2 id="conclusion">Conclusion</h2>

<p>Not having to worry about relative path&rsquo;s inside your require statements is a huge boost to code clarity. I really like this approach and will continue experimenting with it!</p>

<p>Also, remember that this applies to Node.js code as well, it&rsquo;s not limited to Browserify. It could also be a great way of making it easy to share code between client and server!</p>

<p>Thanks Paolo, for the tip!</p>

      </div>
    </article>
      </section>

      <footer class="page-footer">
         <p>
            All content and code on this site is provided under the MIT license.
         </p>
         <nav>
            <ol>
               <li><a href="https://twitter.com/simmelj">@simmelj</a></li>
               <li><a href="https://github.com/simme">GitHub</a></li>
            </ol>
         </nav>
      </footer>
   </body>
</html>

